"""
Script to generate plots of the postfit b-tagging SFs, combining information from
the CDI file as well as the fit result.

** Note: due to some low-level differences in how the central b-tagging code treats
   MV2 and the DL1* taggers, only the former is supported out of the box at the moment.  ***

Author: Philipp Windischhofer
Date:   November 2019
Email:  philipp.windischhofer@cern.ch

usage: ComparePrefitPostfitSF.py [-h] [--CDI_path CDI_PATH]
                                 [--FCC_path FCC_PATH] [--outdir OUTDIR]
                                 [--WP WP] [--jet_collection JET_COLLECTION]

compare prefit and postfit flavour tagging scale factors

optional arguments:
  -h, --help            show this help message and exit
  --CDI_path CDI_PATH   path to the CDI file that was used in the fit, default
                        is the official CDI file released in 10/2019 by the
                        FTAG group
  --FCC_path FCC_PATH   path to the fit result generated by
                        FitCrossChecksForLimits.C, usually found in
                        /fccs/FitCrossChecks.root
  --outdir OUTDIR       output directory where all plots will appear
  --WP WP               tagger working point that was used in the fit, either
                        'FixedCutBEff_..' or 'Continuous'
  --jet_collection JET_COLLECTION
                        jet collection, using the naming convention from the
                        CDI
"""


import ROOT
ROOT.PyConfig.IgnoreCommandLineOptions = True
ROOT.gROOT.SetBatch(1)
ROOT.gROOT.ProcessLine('.L CDIUtils.C')

from argparse import ArgumentParser
from array import array
import numpy as np
import os

from FCCParser import FCCParser
from Plotter import Plotter

def _extract_pT(hist):
    """
    Extract the pT values at which the stored SF values are evaluated.
    """
    number_pT_bins = hist.GetNbinsX()
    pTs = [hist.GetXaxis().GetBinCenter(ind + 1) for ind in range(number_pT_bins)]
    return np.array(pTs)

def _extract_SF(hist, variation_name):
    """
    Extract the SF values for a certain systematic variation.
    """
    syst_bin_ind = hist.GetYaxis().FindBin(variation_name)
    number_pT_bins = hist.GetNbinsX()    
    SF_vals = [hist.GetBinContent(ind + 1, syst_bin_ind) for ind in range(number_pT_bins)]
    return np.array(SF_vals)

def _available_systematics(hist):
    all_variations = list(map(str, hist.GetYaxis().GetLabels()))
    all_variations.remove("Nominal")
    return all_variations

def _get_common_name(syst):
    syst = syst.replace('__1down', '')
    syst = syst.replace('__1up', '')
    return syst

def _convert_to_upvar(syst):
    if not "Nominal" in syst or "nominal" in syst:
        if syst.endswith('__1down') or syst.endswith('__1up'):
            syst = syst.replace('__1down', '__1up')
        else:
            syst = syst + '__1up'
    return syst

def _evaluate_obj(pT, pTs, obj):
    return np.interp(pT, pTs, obj)

def GetPostfitSF(nuis_names, nuis_values, nuis_cov, CDI_path, tagger = "DL1r", WP = "FixedCutBEff_70", jet_collection = "AntiKt4EMPFlowJets_BTagging201903", efficiency_map = "default",
                 jet_flavour = 5, jet_eta = 0.0, pT_min = 20, pT_max = 300, pT_stepsize = 1, MV2_score = 0.95):
    """
    Compute the postfit SF and postfit uncertainty, given some nuisance parameter values and covariances.
    """

    nuis_values = np.array(nuis_values)

    hist = ROOT.FillSFHistogram(CDI_path, tagger, WP, jet_collection, efficiency_map, jet_flavour, jet_eta, pT_min, pT_max, pT_stepsize, MV2_score)
    available_systematics = _available_systematics(hist)
    available_upvars = sorted(list(set(map(_convert_to_upvar, available_systematics))))
    
    SF_nominal = _extract_SF(hist, "Nominal")
    pTs = _extract_pT(hist)

    # get the individual (normalised) variations and their corresponding (base) nuisance names
    # Note: this assumes (for now) that the up/down variations are symmetric (which they indeed seem to be, after a bit of checking)
    response_vects = []
    for cur_nuis in nuis_names:
        cur_upvar = _convert_to_upvar(cur_nuis)
        
        if not cur_upvar in available_upvars:
            raise Exception(f"Error: systematic '{cur_nuis}' is not available in this CDI!")

        SF_cur = _extract_SF(hist, cur_upvar)
        response_vects.append(SF_cur - SF_nominal)

    # for later convenience, put them as column vectors into a matrix with shape (number_pT_bins, number_nuisances)
    response_mat = np.stack(response_vects, axis = 1)

    # now, compute the postfit scale factor
    SF_postfit = SF_nominal + np.matmul(response_mat, nuis_values)

    # now, compute the postfit covariance matrix in bins of pT
    SF_postfit_cov = np.linalg.multi_dot([response_mat, nuis_cov, np.transpose(response_mat)])

    # use the variances as simple (but not exact) measure of uncertainty in each pT bin
    SF_postfit_unc = np.sqrt(np.diagonal(SF_postfit_cov))

    return pTs, SF_postfit, SF_postfit_unc

def ComparePrefitPostfitSFContinuous(CDI_path, FCC_path, outdir, jet_collection = "AntiKt4EMPFlowJets", jet_flavour = 5, jet_eta = 0.0, pT_bin_edges_plots = [20, 50, 100, 150, 300], verbose = True):

    nuis_names = ['FT_EFF_Eigen_B_0', 'FT_EFF_Eigen_B_1', 'FT_EFF_Eigen_B_2', 'FT_EFF_Eigen_B_3', 'FT_EFF_Eigen_B_4', 'FT_EFF_Eigen_B_5', 'FT_EFF_Eigen_B_6', 'FT_EFF_Eigen_B_7', 'FT_EFF_Eigen_B_8', 'FT_EFF_Eigen_B_9', 'FT_EFF_Eigen_B_10', 'FT_EFF_Eigen_B_11', 'FT_EFF_Eigen_B_12', 'FT_EFF_Eigen_B_13', 'FT_EFF_Eigen_B_14', 'FT_EFF_Eigen_B_15', 'FT_EFF_Eigen_B_16', 'FT_EFF_Eigen_B_17', 'FT_EFF_Eigen_B_18', 'FT_EFF_Eigen_B_19', 'FT_EFF_Eigen_B_20', 'FT_EFF_Eigen_B_21', 'FT_EFF_Eigen_B_22', 'FT_EFF_Eigen_B_23', 'FT_EFF_Eigen_B_24', 'FT_EFF_Eigen_B_25', 'FT_EFF_Eigen_B_26', 'FT_EFF_Eigen_B_27', 'FT_EFF_Eigen_B_28', 'FT_EFF_Eigen_B_29', 'FT_EFF_Eigen_B_30', 'FT_EFF_Eigen_B_31', 'FT_EFF_Eigen_B_32', 'FT_EFF_Eigen_B_33', 'FT_EFF_Eigen_B_34', 'FT_EFF_Eigen_B_35', 'FT_EFF_Eigen_B_36', 'FT_EFF_Eigen_B_37', 'FT_EFF_Eigen_B_38', 'FT_EFF_Eigen_B_39', 'FT_EFF_Eigen_B_40', 'FT_EFF_Eigen_B_41', 'FT_EFF_Eigen_B_42', 'FT_EFF_Eigen_B_43', 'FT_EFF_Eigen_C_0', 'FT_EFF_Eigen_C_1', 'FT_EFF_Eigen_C_2', 'FT_EFF_Eigen_C_3', 'FT_EFF_Eigen_C_4', 'FT_EFF_Eigen_C_5', 'FT_EFF_Eigen_C_6', 'FT_EFF_Eigen_C_7', 'FT_EFF_Eigen_C_8', 'FT_EFF_Eigen_C_9', 'FT_EFF_Eigen_C_10', 'FT_EFF_Eigen_C_11', 'FT_EFF_Eigen_C_12', 'FT_EFF_Eigen_C_13', 'FT_EFF_Eigen_C_14', 'FT_EFF_Eigen_C_15', 'FT_EFF_Eigen_C_16', 'FT_EFF_Eigen_C_17', 'FT_EFF_Eigen_C_18', 'FT_EFF_Eigen_Light_0', 'FT_EFF_Eigen_Light_1', 'FT_EFF_Eigen_Light_2', 'FT_EFF_Eigen_Light_3', 'FT_EFF_Eigen_Light_4', 'FT_EFF_Eigen_Light_5', 'FT_EFF_Eigen_Light_6', 'FT_EFF_Eigen_Light_7', 'FT_EFF_Eigen_Light_8', 'FT_EFF_Eigen_Light_9', 'FT_EFF_Eigen_Light_10', 'FT_EFF_Eigen_Light_11', 'FT_EFF_Eigen_Light_12', 'FT_EFF_Eigen_Light_13', 'FT_EFF_Eigen_Light_14', 'FT_EFF_Eigen_Light_15', 'FT_EFF_Eigen_Light_16', 'FT_EFF_Eigen_Light_17', 'FT_EFF_Eigen_Light_18']

    tagger = "DL1r" # only MV2 is supported for continuous tagging so far

    # first, assemble the tagweight bin edges: in total, have 5 tag-weight bins
    fixed_cut_WPs = ["FixedCutBEff_85", "FixedCutBEff_77", "FixedCutBEff_70", "FixedCutBEff_60"]
    cutvalues = [ROOT.GetTaggerWeightCutValue(CDI_path, tagger, jet_collection, WP) for WP in fixed_cut_WPs]
    tagweight_bin_edges = np.array([-1.0e4] + cutvalues + [1.0e4])

    tagweight_bin_centers = 0.5 * (tagweight_bin_edges[:-1] + tagweight_bin_edges[1:])
    tagweight_bin_names = ["85-100%", "77-85%", "70-77%", "60-70%", "0-60%"]
    
    print(f"Have the following pseudocontinuous bin edges: {tagweight_bin_edges}")
    print("Using the following pseudocontinuous bin centers:")
    for cur_bin_name, cur_bin_center in zip(tagweight_bin_names, tagweight_bin_centers):
        print(f"{cur_bin_name}: {cur_bin_center}")

    # load the prefit and postfit SF curves (as functions of pT) for these tagweight-bins
    prefit_SFs = {}
    postfit_SFs = {}

    nuis_values_prefit = np.zeros(len(nuis_names))
    nuis_cov_prefit = np.eye(len(nuis_names))

    parser = FCCParser(FCC_path, fit_to = "Data", fit_type = "conditional_1")
    nuis_values_postfit, _ = parser.get_param_values_uncs(nuis_names)
    nuis_cov_postfit = parser.get_covariance_matrix(nuis_names)

    if verbose:
        print("prefit nuisance values:")
        for nuis_name, nuis_pull in zip(nuis_names, nuis_values_prefit):
            print(f"{nuis_name}: {nuis_pull}")

        print("postfit nuisance values:")
        for nuis_name, nuis_pull in zip(nuis_names, nuis_values_postfit):
            print(f"{nuis_name}: {nuis_pull}")

    for tagweight_bin_name, tagger_score in zip(tagweight_bin_names, tagweight_bin_centers):
        pTs, prefit_SF, prefit_SF_unc = GetPostfitSF(nuis_names, nuis_values_prefit, nuis_cov_prefit, CDI_path, tagger = tagger, WP = "Continuous", jet_collection = jet_collection,
                                                     jet_flavour = jet_flavour, jet_eta = jet_eta, MV2_score = tagger_score)
        prefit_SFs[tagweight_bin_name] = {"pTs": pTs, "value": prefit_SF, "uncertainty": prefit_SF_unc}
                
        pTs, postfit_SF, postfit_SF_unc = GetPostfitSF(nuis_names, nuis_values_postfit, nuis_cov_postfit, CDI_path, tagger = tagger, WP = "Continuous", jet_collection = jet_collection,
                                                       jet_flavour = jet_flavour, jet_eta = jet_eta, MV2_score = tagger_score)
        postfit_SFs[tagweight_bin_name] = {"pTs": pTs, "value": postfit_SF, "uncertainty": postfit_SF_unc}

    # first, plot the SF as a function of pT, separately for each tag-weight bin
    for tagweight_bin_name in tagweight_bin_names:
        pTs = prefit_SFs[tagweight_bin_name]["pTs"]
        prefit_SF = prefit_SFs[tagweight_bin_name]["value"]
        prefit_SF_unc = prefit_SFs[tagweight_bin_name]["uncertainty"]
    
        postfit_SF = postfit_SFs[tagweight_bin_name]["value"]
        postfit_SF_unc = postfit_SFs[tagweight_bin_name]["uncertainty"]

        inner_label = "#splitline{{{tagger}, {tagweight_bin}, jet flavour = {jet_flavour}, |#eta| = {jet_eta}}}{{{jet_collection}}}".format(tagger = tagger, tagweight_bin = tagweight_bin_name, 
                                                                                                                                            jet_collection = jet_collection, jet_flavour = jet_flavour, jet_eta = jet_eta)
        tagweight_desc = tagweight_bin_name.rstrip('%').replace('-', '_')
        filename = "SF_prefit_postfit_{tagger}_{WP}_jet_flavour_{jet_flavour}.pdf".format(tagger = tagger, WP = "continuous_" + tagweight_desc, jet_flavour = jet_flavour)

        prefit_color = ROOT.TColor.GetColor(207, 122, 48)
        postfit_color = ROOT.TColor.GetColor(0, 119, 112)
        Plotter.plot_curves(curves_x = [pTs, pTs], curves_y = [prefit_SF, postfit_SF], 
                            uncs = [prefit_SF_unc, postfit_SF_unc], labels = ["prefit", "postfit"],
                            line_colors = [prefit_color, postfit_color], unc_colors = [prefit_color, postfit_color],
                            outfile = os.path.join(outdir, filename),
                            ratio_reference = prefit_SF,
                            inner_label = inner_label)

    # then, plot the scale factors as a function of the tag-weight bin, separately for different pTs
    pT_bin_edges_plots = np.array(pT_bin_edges_plots)
    pT_bin_lower_edges_plots = pT_bin_edges_plots[:-1]
    pT_bin_upper_edges_plots = pT_bin_edges_plots[1:]
    pT_bin_centers_plots = 0.5 * (pT_bin_lower_edges_plots + pT_bin_upper_edges_plots)
    
    for cur_pT_bin_center, cur_pT_bin_lower_edge, cur_pT_bin_upper_edge in zip(pT_bin_centers_plots, pT_bin_lower_edges_plots, pT_bin_upper_edges_plots):
        inner_label = "#splitline{{{tagger}, {pT_bin}, jet flavour = {jet_flavour}, |#eta| = {jet_eta}}}{{{jet_collection}}}".format(tagger = tagger, 
                                                                                                                                     pT_bin = f"{cur_pT_bin_lower_edge} < p_{{T}} < {cur_pT_bin_upper_edge} GeV", 
                                                                                                                                     jet_collection = jet_collection, jet_flavour = jet_flavour, jet_eta = jet_eta)
        pT_desc = f"{cur_pT_bin_lower_edge}_{cur_pT_bin_upper_edge}_GeV"
        filename = f"SF_prefit_postfit_{tagger}_continuous_{pT_desc}_jet_flavour_{jet_flavour}.pdf"

        plot_prefit_SFs = []
        plot_prefit_SF_uncs = []

        plot_postfit_SFs = []
        plot_postfit_SF_uncs = []

        for tagweight_bin_name in tagweight_bin_names:
            prefit_SF = _evaluate_obj(cur_pT_bin_center, prefit_SFs[tagweight_bin_name]["pTs"], prefit_SFs[tagweight_bin_name]["value"])
            prefit_SF_unc = _evaluate_obj(cur_pT_bin_center, prefit_SFs[tagweight_bin_name]["pTs"], prefit_SFs[tagweight_bin_name]["uncertainty"])

            postfit_SF = _evaluate_obj(cur_pT_bin_center, postfit_SFs[tagweight_bin_name]["pTs"], postfit_SFs[tagweight_bin_name]["value"])
            postfit_SF_unc = _evaluate_obj(cur_pT_bin_center, postfit_SFs[tagweight_bin_name]["pTs"], postfit_SFs[tagweight_bin_name]["uncertainty"])

            plot_prefit_SFs.append(prefit_SF)
            plot_prefit_SF_uncs.append(prefit_SF_unc)

            plot_postfit_SFs.append(postfit_SF)
            plot_postfit_SF_uncs.append(postfit_SF_unc)

        plot_prefit_SFs = np.array(plot_prefit_SFs)
        plot_prefit_SF_uncs = np.array(plot_prefit_SF_uncs)
        plot_postfit_SFs = np.array(plot_postfit_SFs)
        plot_postfit_SF_uncs = np.array(plot_postfit_SF_uncs)

        # make the categorical plot
        prefit_color = ROOT.TColor.GetColor(207, 122, 48)
        postfit_color = ROOT.TColor.GetColor(0, 119, 112)
        Plotter.plot_categories(cat_labels = tagweight_bin_names, cat_values = [plot_prefit_SFs, plot_postfit_SFs], cat_uncs = [plot_prefit_SF_uncs, plot_postfit_SF_uncs],
                                labels = ["prefit", "postfit"], inner_label = inner_label, line_colors = [prefit_color, postfit_color], unc_colors = [prefit_color, postfit_color],
                                ratio_reference = plot_prefit_SFs, outfile = os.path.join(outdir, filename))
    

def ComparePrefitPostfitSFFixedCut(CDI_path, FCC_path, outdir, tagger = "DL1r", WP = "FixedCutBEff_70", jet_collection = "AntiKt4EMPFlowJets", jet_flavour = 5, jet_eta = 0.0, verbose = False):
    # make sure that we have a sane WP
    fixed_cut_WPs = ["FixedCutBEff_85", "FixedCutBEff_77", "FixedCutBEff_70", "FixedCutBEff_60"]
    if not WP in fixed_cut_WPs:
        raise Exception("Error: passed working point is not understood, supported are '{}'".format(", ".join(fixed_cut_WPs)))

    nuis_names = ['FT_EFF_Eigen_B_0', 'FT_EFF_Eigen_B_1', 'FT_EFF_Eigen_B_2', 'FT_EFF_Eigen_B_3', 'FT_EFF_Eigen_B_4', 'FT_EFF_Eigen_B_5', 'FT_EFF_Eigen_B_6', 'FT_EFF_Eigen_B_7', 'FT_EFF_Eigen_B_8', 'FT_EFF_Eigen_C_0', 'FT_EFF_Eigen_C_1', 'FT_EFF_Eigen_C_2', 'FT_EFF_Eigen_C_3', 'FT_EFF_Eigen_Light_0', 'FT_EFF_Eigen_Light_1', 'FT_EFF_Eigen_Light_2', 'FT_EFF_Eigen_Light_3', 'FT_EFF_Eigen_Light_4', 'FT_EFF_extrapolation', 'FT_EFF_extrapolation_from_charm']

    # prefit values
    nuis_values_prefit = np.zeros(len(nuis_names))
    nuis_cov_prefit = np.eye(len(nuis_names))
    pTs, prefit_SF, prefit_SF_unc = GetPostfitSF(nuis_names, nuis_values_prefit, nuis_cov_prefit, CDI_path, tagger = tagger, WP = WP, jet_collection = jet_collection,
                                                 jet_flavour = jet_flavour, jet_eta = jet_eta)

    # load the postfit values
    parser = FCCParser(FCC_path, fit_to = "Data", fit_type = "conditional_1")
    nuis_values_postfit, _ = parser.get_param_values_uncs(nuis_names)
    nuis_cov_postfit = parser.get_covariance_matrix(nuis_names)
    
    pTs, postfit_SF, postfit_SF_unc = GetPostfitSF(nuis_names, nuis_values_postfit, nuis_cov_postfit, CDI_path, tagger = tagger, WP = WP, jet_collection = jet_collection,
                                                 jet_flavour = jet_flavour, jet_eta = jet_eta)

    if verbose:
        print("prefit nuisance values:")
        for nuis_name, nuis_pull in zip(nuis_names, nuis_values_prefit):
            print(f"{nuis_name}: {nuis_value}")

        print("postfit nuisance values:")
        for nuis_name, nuis_pull in zip(nuis_names, nuis_values_postfit):
            print(f"{nuis_name}: {nuis_value}")

        print("prefit nuisance covariance matrix:")
        print(nuis_cov_prefit)

        print("postfit nuisance covariance matrix:")
        print(nuis_cov_postfit)

    inner_label = "#splitline{{{tagger}, {WP}, jet flavour = {jet_flavour}, |#eta| = {jet_eta}}}{{{jet_collection}}}".format(tagger = tagger, WP = WP, jet_collection = jet_collection,
                                                                                                                             jet_flavour = jet_flavour, jet_eta = jet_eta)
    filename = f"SF_prefit_postfit_{tagger}_{WP}_jet_flavour_{jet_flavour}.pdf"

    # plot the results
    prefit_color = ROOT.TColor.GetColor(207, 122, 48)
    postfit_color = ROOT.TColor.GetColor(0, 119, 112)
    Plotter.plot_curves(curves_x = [pTs, pTs], curves_y = [prefit_SF, postfit_SF], 
                        uncs = [prefit_SF_unc, postfit_SF_unc], labels = ["prefit", "postfit"],
                        line_colors = [prefit_color, postfit_color], unc_colors = [prefit_color, postfit_color],
                        outfile = os.path.join(outdir, filename),
                        ratio_reference = prefit_SF,
                        inner_label = inner_label)

def MakeAllPrefitPostfitPlots(CDI_path, FCC_path, outdir, WP, jet_collection):
    if "FixedCut" in WP:
        for jet_flavour in [0, 4, 5]:
            ComparePrefitPostfitSFFixedCut(CDI_path, FCC_path, outdir, jet_flavour = jet_flavour, WP = WP, jet_collection = jet_collection)
    elif WP == "Continuous":
        light_jet_pT_bin_edges = [20, 50, 100, 150, 300]
        c_jet_pT_bin_edges = [20, 40, 65, 140, 300]
        b_jet_pT_bin_edges = [20, 30, 40, 60, 85, 110, 140, 175, 250, 600]

        for jet_flavour, pT_bin_edges in zip([0, 4, 5], [light_jet_pT_bin_edges, c_jet_pT_bin_edges, b_jet_pT_bin_edges]):
            ComparePrefitPostfitSFContinuous(CDI_path, FCC_path, outdir, jet_flavour = jet_flavour, pT_bin_edges_plots = pT_bin_edges,
                                             jet_collection = jet_collection)
    else:
        raise Exception("Error: passed value for 'WP' not understood, needs to be either 'FixedCutBEff_..' or 'Continuous'!")

if __name__ == "__main__":
    parser = ArgumentParser(description = "compare prefit and postfit flavour tagging scale factors")
    parser.add_argument("--CDI_path", action = "store", dest = "CDI_path", help = "path to the CDI file that was used in the fit, default is the official CDI file released in 10/2019 by the FTAG group",
                        default = "/eos/atlas/atlascerngroupdisk/asg-calib/xAODBTaggingEfficiency/13TeV/2019-21-13TeV-MC16-CDI-2019-10-07_v1.root")
    parser.add_argument("--FCC_path", action = "store", dest = "FCC_path",
                        help = "path to the fit result generated by FitCrossChecksForLimits.C, usually found in /fccs/FitCrossChecks.root")
    parser.add_argument("--outdir", action = "store", dest = "outdir", help = "output directory where all plots will appear")
    parser.add_argument("--WP", action = "store", default = "Continuous", dest = "WP", help = "tagger working point that was used in the fit, either 'FixedCutBEff_..' or 'Continuous'")
    parser.add_argument("--jet_collection", action = "store", default = "AntiKt4EMPFlowJets_BTagging201903", dest = "jet_collection", help = "jet collection, using the naming convention from the CDI")
    args = vars(parser.parse_args())

    MakeAllPrefitPostfitPlots(**args)
