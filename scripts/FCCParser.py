import ROOT, re, os
import ctypes

class FCCParser:
    """
    Parser to extract information from fcc/FitCrossChecks.root, which is generated by e.g. FitCrossCheckForLimits.C.

    Author: Philipp Windischhofer
    Date:   November 2019
    Email:  philipp.windischhofer@cern.ch

    Description:
        It is useful to be able to extract individual properties of the fit result. This class provides a series of methods to do this.
    """
    
    def __init__(self, inpath, fit_to = "Asimov", fit_type = "unconditional"):
        """
        Creates a new FCCParser.
        Arguments:
            inpath ... full path to the FCC output file, usually located in fcc/FitCrossChecks.root
            fit_to ... type of the data on which the fit is performed, supported are "Asimov" and "Data"
            fit_Type ... type of the fit, supported are "conditional" and "unconditional"
        """

        self.inpath = inpath
        self.fileobj = ROOT.TFile.Open(self.inpath)
        
        if re.compile("(A|a)simov").match(fit_to):
            # asked to use Asimov fit
            self.fit_to = "Asimov"
            fit_path = "PlotsAfterFitToAsimov"
        elif re.compile("(D|d)ata").match(fit_to):
            # asked to use data fit
            self.fit_to = "Global"
            fit_path = "PlotsAfterGlobalFit"
        else:
            raise Exception(f"Error: unsupported fit type '{fit_to}' encountered!")

        if re.compile("(unconditional|uncond)").match(fit_type):
            fit_dir = "unconditionnal"
            self.fit_type_path = fit_dir
            self.mu = 1
        else:
            m = re.compile("(conditional|cond)_(.+)").match(fit_type)
            if m:
                self.mu = m.group(2)
                fit_dir = f"conditionnal_MuIsEqualTo_{self.mu}"
                self.fit_type_path = "conditionnal"
            else:
                raise Exception(f"Error: unsupported fit type '{fit_type}' encountered!")

        self.prefix = os.path.join(fit_path, fit_dir) # global prefix where all fit results are to be found
    
    def __del__(self):
        self.fileobj.Close()

    def get_correlation_matrix(self, pars, fail_on_miss = True):
        """
        Returns the entries of the (reduced) correlation matrix of the fit.
        Arguments:
            pars ... list of names of the fit parameters that should be included
        Returns:
            The correlation matrix in the form of a nested list, with the order of the entries given by the order in 'pars'.
        """

        def get_corrval(par_x, par_y, corr):
            available_corrs = list(map(str, corr.GetXaxis().GetLabels()))
                        
            if par_x not in available_corrs or par_y not in available_corrs:
                if fail_on_miss:
                    raise Exception(f"Error: no correlation information available for parameters '{par_x}' / '{par_y}'!")
                else:
                    print(f"Warning: no correlation information available for systematics '{par_x}' / '{par_y}' - did it get pruned?")

                    # return a diagonal (sub)matrix for non-existant parameter combinations
                    if par_x != par_y:
                        return 0.0
                    else:
                        return 1.0

            bin_x = corr.GetXaxis().FindBin(par_x)
            bin_y = corr.GetYaxis().FindBin(par_y)
            
            return corr.GetBinContent(bin_x, bin_y)

        # fetch the object from the FCC file
        objpath = os.path.join(self.prefix, f"can_CorrMatrix_{self.fit_to}Fit_{self.fit_type_path}_mu{self.mu}")
        print(f"reading from {objpath}")
        corr_canv = self.fileobj.Get(objpath)
        corr_full = corr_canv.GetListOfPrimitives().At(0) # the full correlation matrix

        # assemble the reduced correlation matrix containing only the elements that were requested
        corr_red = [[0.0 for col in range(len(pars))] for row in range(len(pars))]
        labels_red = []

        for ind_x, par_x in enumerate(pars):
            for ind_y, par_y in enumerate(pars):
                corrval = get_corrval(par_x, par_y, corr_full)
                corr_red[ind_x][ind_y] = corrval # only load half of the entries, matrix is manifestly symmetric!

        return corr_red

    @staticmethod
    def convert_to_WSMaker_corr_convention(syst_name):
        """
        Converts the name of a systematic to the convetion used in correlation matrices by WSMaker.
        """
        return "alpha_Sys" + syst_name

    @staticmethod
    def convert_to_WSMaker_pull_convention(syst_name):
        """
        Converts the name of a systematic to the convetion used in pull plots by WSMaker.
        """
        return "Sys" + syst_name

    def get_covariance_matrix(self, param_names):
        """
        Returns the entries of the (reduced) covariance matrix of the fit.
        Arguments:
            param_names ... list of names of fit parameters that should be included
        Returns:
            the covariance matrix in the form of a numpy array
        """
        import numpy as np
        param_names_WSMaker = list(map(FCCParser.convert_to_WSMaker_corr_convention, param_names))
        corr = np.array(self.get_correlation_matrix(param_names_WSMaker, fail_on_miss = False))
        _, param_uncs = self.get_param_values_uncs(param_names)        

        norm = np.outer(param_uncs, param_uncs) # get the rank-1 matrix holding the variances

        print(param_uncs)

        cov = np.multiply(corr, norm)
        return cov

    def get_param_values_uncs(self, param_names):
        """
        Returns the postfit values of fit parameters, and their postfit uncertainties (usually pulls).
        Arguments:
            param_names ... list of names of the fit parameters that should be included
        Returns:
            a tuple (parameter_values, parameter_uncertainties)
        """
        import numpy as np

        def get_param_val_unc(par, labels_hist, pulls_graph):
            available_pulls = list(map(str, labels_hist.GetXaxis().GetLabels()))
            number_pulls = len(available_pulls)
            
            if par not in available_pulls:
                print(f"Warning: no pull information available for systematic '{par}' - did it get pruned?")
                return 0.0, 1.0 # return the prefit values instead

            cur_bin = labels_hist.GetXaxis().FindBin(par)
            par_x = labels_hist.GetBinCenter(cur_bin)

            param_val = 0.0
            param_unc = 1.0
            
            # now look up this point in the graph
            for cur_pull in range(number_pulls):
                point_x, point_y = ctypes.c_double(0.0), ctypes.c_double(0.0)
                pulls_graph.GetPoint(cur_pull, point_x, point_y)
                if point_x.value == par_x:
                    param_val = point_y.value
                    param_unc = pulls_graph.GetErrorY(cur_pull)
                    break

            return param_val, param_unc
        
        pulls_canv = self.fileobj.Get(os.path.join(self.prefix, f"can_NuisPara_{self.fit_to}Fit_{self.fit_type_path}_mu{self.mu}"))

        # first, get the base histogram that holds all the labels for the individual nuisances
        base_hist = pulls_canv.GetListOfPrimitives().At(0)
        pulls_graph = pulls_canv.GetListOfPrimitives().At(3)

        param_values = []
        param_uncs = []

        for par in param_names:
            cur_par_name = FCCParser.convert_to_WSMaker_pull_convention(par)

            # find the point in the graph at this x coordinate
            param_val, param_unc = get_param_val_unc(cur_par_name, base_hist, pulls_graph)
            param_values.append(param_val)
            param_uncs.append(param_unc)

        return np.array(param_values), np.array(param_uncs)


