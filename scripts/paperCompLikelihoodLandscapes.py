"""
A script to visualise the output generated by LikelihoodLandscape.

Author: Brian Moser
Date:   March 2020
Email:  brian.moser@cern.ch

Description:
    Creates the 1D likelihood scan plots shown in the VHbb boosted and resolved publications. Directly compares scan results from linear and linear + quadratic parametrisations and slightly refines the plotting style compared to compareLikelihoodLandscapes.
"""


import ROOT
ROOT.gROOT.SetBatch(True)

from argparse import ArgumentParser

from plotLikelihoodLandscape import Plot2DContours, Tree2Dict, RemoveOutliers, Interpolate, operator_namer, _drawText
from analysisPlottingConfig import Config
import numpy as np
from array import array
import os

def _drawATLASLabel(x, y, text, doNDC = True, fontsize = 0.07):
    """
    Draw a nice ATLAS label.
    """
    _drawText(x, y, "ATLAS", fontsize = fontsize, font = 72, doNDC = doNDC, alignment = 13)
    _drawText(x + 0.14, y, text, fontsize = fontsize, font = 42, doNDC = doNDC, alignment = 13)

def Plot1DProfile(xvals, yvals, labels, colors, outfile_path, xlabel = "", ylabel = "", inner_label = "", lw = [], ls = [], xlim = [], ylim = [0.0, 4.5], fontsize_inner = 0.035, fontsize = 0.04):
    if len(lw) != len(xvals):
        lw = [1 for cur in xvals]

    if len(ls) != len(xvals):
        ls = [1 for cur in xvals]

    plotconf = Config(options = [])

    # set ATLAS plotting style
    macros_dir = os.path.join(os.environ["WORKDIR"], "macros")
    ROOT.gROOT.LoadMacro(os.path.join(macros_dir, "AtlasStyle.C"))
    ROOT.gROOT.LoadMacro(os.path.join(macros_dir, "AtlasUtils.C"))
    ROOT.SetAtlasStyle()
    ROOT.gStyle.SetEndErrorSize(7.0);

    canv = ROOT.TCanvas("canv", "canv", 800, 800)
    ROOT.SetOwnership(canv, False)

    mg = ROOT.TMultiGraph()
    ROOT.SetOwnership(mg, False)

    leg = ROOT.TLegend(0.54, 0.92 - len(labels) * 0.05, 0.74, 0.92)
    ROOT.SetOwnership(leg, False)
    leg.SetBorderSize(0)
    leg.SetFillStyle(0)
    leg.SetTextFont(42)
    leg.SetTextSize(fontsize_inner)

    domain_mins = []
    domain_maxs = []
    for cur_xvals, cur_yvals, cur_label, cur_color, cur_lw, cur_ls in zip(xvals, yvals, labels, colors, lw, ls):

        # find reasonable values for the axis range
        cur_xvals = np.array(cur_xvals)
        cur_yvals = np.array(cur_yvals)
        domain_mins.append(np.min(cur_xvals[cur_yvals < 2.0]))
        domain_maxs.append(np.max(cur_xvals[cur_yvals < 3.0]))

        cur_xval_data = array('d', cur_xvals)
        cur_yval_data = array('d', cur_yvals)

        cur_graph = ROOT.TGraph(len(cur_xval_data), cur_xval_data, cur_yval_data)
        ROOT.SetOwnership(cur_graph, False)
        cur_graph.SetLineColor(cur_color)
        cur_graph.SetLineStyle(cur_ls)
        cur_graph.SetLineWidth(cur_lw)

        mg.Add(cur_graph)
        leg.AddEntry(cur_graph, cur_label, "l")

    canv.cd()

    mg.Draw("al")

    if ylim:
        mg.GetYaxis().SetRangeUser(ylim[0], ylim[1])

    if not xlim:
        domain_min = np.min(domain_mins)
        domain_max = np.max(domain_maxs)
        xlim = [domain_min - (domain_max - domain_min) * 0.34, domain_max + (domain_max - domain_min) * 0.1]

    print(f"setting x-axis limits: {xlim}")
    mg.GetXaxis().SetLimits(xlim[0], xlim[1])
    mg.GetXaxis().SetRangeUser(xlim[0], xlim[1])

    mg.GetXaxis().SetTitle(xlabel)
    mg.GetYaxis().SetTitle(ylabel)
    mg.GetYaxis().SetTickLength(0.02)
    mg.GetXaxis().SetTickLength(0.02)

    mg.GetXaxis().SetTitleSize(fontsize * 1.2)
    mg.GetYaxis().SetTitleSize(fontsize)

    mg.GetXaxis().SetLabelSize(fontsize)
    mg.GetYaxis().SetLabelSize(fontsize)

    # draw additional n\sigma lines
    for CL, linepos in zip([68, 95], [0.494475, 1.92072]):

        ROOT.gPad.Modified()
        ROOT.gPad.Update()
        cur_line = ROOT.TLine(ROOT.gPad.GetUxmin(), linepos,
                              ROOT.gPad.GetUxmax(), linepos)
        ROOT.SetOwnership(cur_line, False)
        cur_line.SetLineWidth(2)
        cur_line.SetLineStyle(2)
        cur_line.SetLineColor(ROOT.kGray)
        cur_line.Draw("same")

        _drawText(ROOT.gPad.GetUxmin() + (ROOT.gPad.GetUxmax() - ROOT.gPad.GetUxmin()) * 0.04, linepos + 0.13, f"{CL}% CL", color = ROOT.kGray, fontsize = fontsize, font = 42, doNDC = False, alignment = 12)

    # draw white rectangle to hide the uninteresting part of the graph
    label_background = ROOT.TBox(ROOT.gPad.GetUxmin(), 3.0, ROOT.gPad.GetUxmax(), ylim[1])
    label_background.SetFillColor(ROOT.kWhite)
    label_background.Draw()

    leg.Draw()

    ROOT.gPad.RedrawAxis()

    # add ATLAS label
    inner_label_x = 0.19
    inner_label_y = 0.89
    _drawATLASLabel(inner_label_x, inner_label_y + 0.02, plotconf.ATLAS_suffix, fontsize = fontsize_inner * 1.2)
    _drawText(inner_label_x, inner_label_y - 0.085, inner_label, fontsize = fontsize_inner)

    canv.SaveAs(outfile_path) # save as pdf

    outfile_png_path = os.path.splitext(outfile_path)[0] + ".png"
    canv.SaveAs(outfile_png_path) # always also save as png for webpage

    outfile_png_path = os.path.splitext(outfile_path)[0] + ".C"
    canv.SaveAs(outfile_png_path) # always also save as root for later modifications

def paperCompLikelihoodLandscapes(lin_infile_paths, quad_infile_paths, outfile_path, year):

    # the library of colors to be used for comparisons
    color_library = [ROOT.kAzure - 5, ROOT.kOrange - 3, ROOT.kBlue, ROOT.kGreen + 2]

    # load the data from each given input file
    data = []
    bestfit = []
    domain_dims = []
    dset = []
    ltype = []
    legend = []

    for cur_infile_path in lin_infile_paths:
        cur_data = Tree2Dict(cur_infile_path, "NLLscan")
        cur_bestfit = Tree2Dict(cur_infile_path, "bestFit")
        cur_domain_dims = len([col for col in cur_data.keys() if "NLL" not in col])
        if "Asimov" in cur_infile_path:
            dset.append("Asimov")
        elif "Data" in cur_infile_path:
            dset.append("Data")
        else:
            dset.append("Unknown")

        data.append(cur_data)
        bestfit.append(cur_bestfit)
        domain_dims.append(cur_domain_dims)
        ltype.append("Linear")
        legend.append("Linear ")

    for cur_infile_path in quad_infile_paths:
        cur_data = Tree2Dict(cur_infile_path, "NLLscan")
        cur_bestfit = Tree2Dict(cur_infile_path, "bestFit")
        cur_domain_dims = len([col for col in cur_data.keys() if "NLL" not in col])
        if "Asimov" in cur_infile_path:
            dset.append("Asimov")
        elif "Data" in cur_infile_path:
            dset.append("Data")
        else:
            dset.append("Unknown")

        data.append(cur_data)
        bestfit.append(cur_bestfit)
        domain_dims.append(cur_domain_dims)
        ltype.append("Quadratic")
        legend.append("Linear + quadratic ")

    if len(set(domain_dims)) != 1:
        raise Exception("Error: you are requesting to make comparison plots of runs with different dimensionalities!")

    domain_dims = domain_dims[0]

    # prepare the inner label text
    plotconf = Config(options = [])
    plotconf._year = year
    runinfo = plotconf.get_run_info()
    lumi, energy = list(runinfo.values())[0]
    signaldesc = plotconf.signal[0]
    lambdaval = plotconf.EFT_lambda
    inner_label = f"#splitline{{#sqrt{{s}} = {energy} TeV, {lumi} fb^{{-1}}}}{{{signaldesc}, #Lambda = {lambdaval} TeV}}"

    # extract some meta information from the data: which operators it concerns ...
    available_operators = list({col for cur_data in data for col in cur_data.keys() if "NLL" not in col})

    # ... and of what type the available NLL values are
    available_NLL = [col for col in cur_data.keys() if "NLL" in col for cur_data in data]
    if len(set(available_NLL)) != 1:
        raise Exception("Error: you are requesting to compare runs with different NLL types!")
    NLL_column = available_NLL[0]

    if domain_dims == 1:

        if len(available_operators) != 1:
            raise Exception("Error: you are requesting to compare runs with different POIs!")

        available_operator = available_operators[0]

        # fetch the data to make a 1D comparison plot
        xvals = []
        yvals = []
        colors = []
        xlabel = operator_namer(available_operator, plotconf)
        ylabel = "- log(L / L_{max})"
        lw = []
        ls = []

        def renormalizeValues(vals):
            newVals = []
            mini = np.min(np.array(vals))
            if mini < 0:
                for val in vals:
                    val = val - mini
                    newVals.append(val)
                return newVals
            else:
                return vals

        cdidx = 0
        for cur_data in data:
            sorter = np.argsort(cur_data[available_operator])
            cur_data[available_operator] = np.array(cur_data[available_operator])[sorter]
            cur_data[NLL_column] = np.array(cur_data[NLL_column])[sorter]

            renormdat = renormalizeValues(cur_data[NLL_column])

            cur_yvals = renormdat
            cur_xvals = cur_data[available_operator]

            yvals.append(cur_yvals)
            xvals.append(cur_xvals)

            if ltype[cdidx] == "Linear":
                colors.append(ROOT.kAzure - 5)
            elif ltype[cdidx] == "Quadratic":
                colors.append(ROOT.kOrange - 3)

            if dset[cdidx] == "Asimov":
                lw.append(1)
                ls.append(2)
                legend[cdidx] += "(exp.)"
            elif dset[cdidx] == "Data":
                lw.append(3)
                ls.append(1)
                legend[cdidx] += "(obs.)"

            cdidx += 1

        Plot1DProfile(xvals, yvals, legend, colors, outfile_path, xlabel = xlabel, ylabel = ylabel, inner_label = inner_label, lw = lw, ls = ls)

    elif domain_dims == 2:

        # check if all runs actually concern the same two operators
        available_operators = list({col for cur_data in data for col in list(cur_data.keys()) if "NLL" not in col})

        if len(available_operators) != 2:
            raise Exception("Error: you are requesting to compare runs with incompatible POIs!")

        x_column = available_operators[0]
        y_column = available_operators[1]
        print(f"Plotting along x: {x_column}")
        print(f"Plotting along y: {y_column}")

        # print the 1-sigma CL contours - make sure to append this information to the legend
        contour_levels = [1.15, 3.00]
        contour_labels = ["68% CL.", "95% CL."]
        contour_ls = [7, 1]

        # now prepare the data to be plotted
        plot_data = []
        plot_bestfit = []
        colors = []
        lw = []
        ls = []
        xlabel = operator_namer(x_column, plotconf)
        ylabel = operator_namer(y_column, plotconf)

        for cur_color, cur_data, cur_bestfit in zip(color_library, data, bestfit):
            (new_xvals, new_yvals), new_zvals = RemoveOutliers(xvals = [cur_data[x_column], cur_data[y_column]],
                                                               zvals = cur_data[NLL_column])
            interpolated_data = Interpolate(xvals = new_xvals, yvals = new_yvals, zvals = new_zvals)
            plot_data.append(interpolated_data)
            colors.append(cur_color)
            lw.append(3)
            plot_bestfit.append([cur_bestfit[x_column][0], cur_bestfit[y_column][0]])

        # then, print the contour lines coming from this surface
        Plot2DContours(plot_data, legend, colors, outfile_path, contour_levels,
                       contour_labels = contour_labels, cont_ls = contour_ls, xlabel = xlabel,
                       ylabel = ylabel, lw = lw, bestfit = plot_bestfit, inner_label = inner_label)
    else:
        raise NotImplementedError(f"Error: can not create comparison plots with {domain_dims} x-dimensions (yet).")

if __name__ == "__main__":
    parser = ArgumentParser(description = "make comparison plots of different LikelihoodLandscape runs")
    parser.add_argument("--lin_infiles", nargs = '+', dest = "lin_infile_paths", help = "path to the individual 'LikelihoodLandscape_out.root' files from linear scans")
    parser.add_argument("--quad_infiles", nargs = '+', dest = "quad_infile_paths", help = "path to the individual 'LikelihoodLandscape_out.root' files from quadratic scans", default = [])
    parser.add_argument("--outfile", action = "store", dest = "outfile_path", help = "path to the requested comparison plot")
    parser.add_argument("--year", action = "store", dest = "year", default = "6051", help = "data-taking periods used to make this plot, following WSMaker convention. Default: 6051, i.e. full Run 2")
    args = vars(parser.parse_args())

    paperCompLikelihoodLandscapes(**args)

