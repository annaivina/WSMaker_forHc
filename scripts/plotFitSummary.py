"""
This is a simple script to generate summary plots of fit results, which show a collection of
best-fit points.

Author: Philipp Windischhofer
Date:   August 2019
Email:  philipp.windischhofer@cern.ch

Description:
    Given a list of files generated by runLikelihoodLandscape, extract the corresponding best-fit values
    (and the corresponding Minos uncertainties) found in each case, and draw all of them in a combined plot.
    Also allows to compare results coming from fits with different numbers of POIs (square brackets are
    drawn around the markers to show which results were fitted simultaneously).
"""

import ROOT
ROOT.gROOT.SetBatch(True)
import numpy as np
import os

from argparse import ArgumentParser
from plotLikelihoodLandscape import Tree2Dict
from array import array

def makeGroupedListPlot(plotdata, unc_up, unc_down, labels, colors, outfile, plot_label = ""):
    macros_dir = os.path.join(os.environ["WORKDIR"], "macros")
    ROOT.gROOT.LoadMacro(os.path.join(macros_dir, "AtlasStyle.C"))
    ROOT.gROOT.LoadMacro(os.path.join(macros_dir, "AtlasUtils.C"))
    ROOT.SetAtlasStyle()
    ROOT.gStyle.SetEndErrorSize(7.0);

    canv = ROOT.TCanvas("canv", "canv", 800, 600)
    ROOT.SetOwnership(canv, False)

    mg = ROOT.TMultiGraph()
    ROOT.SetOwnership(mg, False)

    global_ind = 0.0
    for group_plotdata, group_unc_up, group_unc_down, group_colors in zip(plotdata, unc_up, unc_down, colors):
        for cur_plotdata, cur_unc_up, cur_unc_down, cur_color in zip(group_plotdata, group_unc_up, group_unc_down, group_colors):
            # will need to make a separate TGraph for every marker,
            # to ensure that can set the marker properties independently for everyone
            global_ind += 1.0
            cur_graph = ROOT.TGraphAsymmErrors(1, array('d', [cur_plotdata]), array('d', [global_ind]), array('d', [abs(cur_unc_down)]),
                                               array('d', [abs(cur_unc_up)]), array('d', [0.0]), array('d', [0.0]))
            ROOT.SetOwnership(cur_graph, False)
            cur_graph.SetMarkerColor(cur_color);
            cur_graph.SetMarkerStyle(21);
            mg.Add(cur_graph)

    canv.cd()
    mg.Draw("ap")
    mg.GetYaxis().SetRangeUser(0.5, global_ind + 0.5)

    flatten = lambda l: [item for sublist in l for item in sublist]

    boundary_left = 1.4 * np.min(np.array(flatten(unc_down)) + np.array(flatten(plotdata))) - 1.0
    boundary_right = 1.4 * np.max(np.array(flatten(unc_up)) + np.array(flatten(plotdata))) + 0.5
    plot_width = boundary_right - boundary_left

    mg.GetXaxis().SetLimits(boundary_left, boundary_right) # ensure to leave some space on the left for the labels
    mg.Draw("ap")

    # remove the Y-axis ticks
    mg.GetYaxis().SetLabelOffset(999);
    mg.GetYaxis().SetLabelSize(0);

    global_ind = 0.0
    for group_labels in labels:
        # add the labels for the entries in this group ...
        for cur_label in group_labels:
            global_ind += 1.0
            l = ROOT.TLatex()
            ROOT.SetOwnership(l, False)
            l.SetTextSize(0.045)
            l.SetTextFont(42)
            l.SetTextAlign(22)
            l.SetTextColor(ROOT.kBlack)
            l.DrawLatex(boundary_left + 0.22 * plot_width, global_ind, cur_label)

        # ... and group indicators
        group_length = len(group_labels)
        ystart = global_ind + 0.2
        yend = global_ind - (group_length - 1) - 0.2

        # draw the vertical lines
        l = ROOT.TLine()
        ROOT.SetOwnership(l, False)
        l.DrawLine(boundary_left + 0.06 * plot_width, ystart, boundary_left + 0.06 * plot_width, yend)
        l.DrawLine(boundary_right - 0.06 * plot_width, ystart, boundary_right - 0.06 * plot_width, yend)

        # draw the horizontal line segments to make them into parentheses
        l.DrawLine(boundary_left + 0.06 * plot_width, ystart, boundary_left + 0.068 * plot_width, ystart)
        l.DrawLine(boundary_left + 0.06 * plot_width, yend, boundary_left + 0.068 * plot_width, yend)

        l.DrawLine(boundary_right - 0.06 * plot_width, ystart, boundary_right - 0.068 * plot_width, ystart)
        l.DrawLine(boundary_right - 0.06 * plot_width, yend, boundary_right - 0.068 * plot_width, yend)

    # draw the global plot label
    l = ROOT.TLatex()
    ROOT.SetOwnership(l, False)
    l.SetTextAlign(31)
    l.DrawLatexNDC(0.94, 0.90, plot_label)

    canv.SetLeftMargin(0.04)
    canv.SetBottomMargin(0.09)
    canv.SetTopMargin(0.13)

    canv.SaveAs(outfile)

def plotFitSummary(infiles, outfile):
    labels_dict = {"asimov": "expected", "data": "observed"}
    colors_dict = {"asimov": ROOT.kBlue, "data": ROOT.kRed}

    # load the best-fit values from the passed list of files
    plotdata = []
    unc_up = []
    unc_down = []
    labels = []
    colors = []

    plot_label = ""

    for infile_path in infiles:
        cur_data = Tree2Dict(infile_path, tree_name = "bestFit")

        group_plotdata = []
        group_unc_up = {}
        group_unc_down = {}
        group_labels = []
        group_colors = []
        for cur_name, cur_value in cur_data.items():
            if "_unc_up" in cur_name:
                group_unc_up[cur_name.replace("_unc_up", "")] = cur_value[0]
            elif "_unc_down" in cur_name:
                group_unc_down[cur_name.replace("_unc_down", "")] = cur_value[0]
            else:
                group_plotdata.append(cur_value[0])
                group_labels.append(cur_name)

            if "asimov" in infile_path.lower():
                group_colors.append(colors_dict["asimov"])
                if not plot_label:
                    plot_label = labels_dict["asimov"]
            else:
                group_colors.append(colors_dict["data"])
                if not plot_label:
                    plot_label = labels_dict["data"]

        unc_up.append([group_unc_up[cur] for cur in group_labels])
        unc_down.append([group_unc_down[cur] for cur in group_labels])
        plotdata.append(group_plotdata)
        labels.append(group_labels)
        colors.append(group_colors)

    makeGroupedListPlot(plotdata, unc_up, unc_down, labels, colors, outfile, plot_label)

if __name__ == "__main__":
    parser = ArgumentParser(description = "generate overview plots of several fit results")
    parser.add_argument("infiles", nargs = '+', action = "store")
    parser.add_argument("--out", action = "store", dest = "outfile", help = "path to the generated plot")
    args = vars(parser.parse_args())

    plotFitSummary(**args)
